<?php
/* @var $op ServiceOperation */
/* @var $model RPCClientRenderer */
echo '<?php'.PHP_EOL;
$classMap = Foomo\AutoLoader::getClassMap();
?>

/**
  * DO NOT EDIT !!!
  *
  * the contents of this file were autogenerated on <?= Foomo\Utils::getServerUrl(); ?> on <?= date('Y-m-d H:i:s', time()) . PHP_EOL; ?>
  *
  */

  
// RPC protocol and value object classes

/**

List of classes and files

<? foreach($model->getSortedClassesToImport() as $type): ?>
<?
$instRefl = new ReflectionClass($type);
if(isset($classMap[strtolower($type)])) {
	echo '' . $instRefl->getName() . ' from : ' . $classMap[strtolower($type)] . PHP_EOL;
}
?>
<?php
/*
 * // does not work with namepaces ...
	$classFileContents = explode(PHP_EOL, trim(file_get_contents($classMap[strtolower($type)])));
	foreach(array('<?php', '<?') as $search) {
		if(strpos($classFileContents[0], $search) === 0) { 
			$classFileContents[0] = substr($classFileContents[0],strlen($search));
			break;
		}
		
	}
	$last = count($classFileContents)-1;
	if($classFileContents[$last] == '?>') {
		unset($classFileContents[$last]);
	}
	
	echo PHP_EOL . '	' . implode(PHP_EOL . '	', $classFileContents) . PHP_EOL;

 */
?>
<?php endforeach; ?>

*/
<?

$serviceRefl = new ReflectionClass($model->serviceName);

$hasNamespace = false;

if($serviceRefl->getNamespaceName() != '') {
	$hasNamespace = true;
	echo 'namespace ' . $serviceRefl->getNamespaceName() .';' . PHP_EOL . PHP_EOL;
}

// @todo @throws  and @serviceMessage are missing in doc comments

?>

class <?= $hasNamespace?substr($serviceRefl->getName(), strlen($serviceRefl->getNamespaceName())+1):$serviceRefl->getName() ?>Proxy extends \Foomo\Services\RPC\Client {
  const VERSION = <?= constant($model->serviceName.'::VERSION'); ?>;
  /**
   * construct a client
   *
   * @param RPCSerializerInterface $serializer
   * @param string $targetClass name of the class to talk to
   * @param string $endPoint uri of the service
   */
   
  public function __construct($endPoint = '<?= Foomo\Utils::getServerUrl() . html_entity_decode($model->endPoint); ?>')
  {
    $targetClass = '<?= $model->serviceName ?>';
    $serializer = new \<?= $model->serializerClassName ?>();
    parent::__construct($serializer, $targetClass, $endPoint);
  }

<?php foreach($model->operations as $op): ?>
  /**
    * <?= str_replace(PHP_EOL , PHP_EOL . '    * ', $op->comment) . PHP_EOL ?>
    *
<?php 
$parameterDocs = '';
$parameterArgs = array();
$plainArgs = array();
foreach($op->parameterDocs as $parameterName => $parameterDoc) {
  /* @var $parameterDoc Foomo\Reflection\PhpDocArg */
   $parameterDocs .= '    * @param ' . $parameterDoc->type . ' $' . $parameterDoc->name . ' ' . $parameterDoc->comment . PHP_EOL;
   switch($parameterDoc->type) {
     case'integer':
     case'string':
     case'mixed':
     case'array':
     case'boolean':
     case'float':
       $typePrefix = '';
       break;
     default:
       if(strpos($parameterDoc->type,'[]') === false && class_exists($parameterDoc->type)) {
         $typePrefix = $parameterDoc->type . ' ';
       }
   }
   $parameterArgs[] = $typePrefix . '$' . $parameterDoc->name;
   $plainArgs[] = '$' . $parameterDoc->name;
}
if(strlen($parameterDocs) > 0) {
  $parameterDocs .= '    *' . PHP_EOL;
}
if(isset($op->returnType)) {
  $parameterDocs .= '    * @return ' . $op->returnType->type . ' ' . $op->returnType->comment . PHP_EOL;
}
echo $parameterDocs;
?>    */
  public function <?= $op->name ?>(<?= implode(', ', $parameterArgs) ?>) {
    return $this->callServer(self::VERSION, '<?= $op->name; ?>', array(<?= implode(', ', $plainArgs) ?>));
  }

<?php endforeach; ?>
  public function __call($name, $arguments)
  {
    throw new Exception('function ' . $name .' does not exist - maybe you need to recompile and update your client', 1);
  }
}